

Requirements
	- Basic knowledge of one high-level language	OK
	- RasPi 3 or 4					OK
	- USB to TTL cable				OK

#########################################################
#							#
#	   SECTION 2 - COMPUTER ARCHITECTURE		#
#							#
#########################################################

2 - Intro to Computer Arch
--------------------------

    Main memory representation

		 MSB	       LSB
	Address   7 6 5 4 3 2 1 0
	00000000 |1|0|0|1|1|0|0|1| Byte (8 bits)
	00000001 |0|0|0|0|0|1|1|1| Half word (2 bytes)
	00000002 |0|1|0|0|1|0|1|0|
	00000003 |0|1|0|0|1|0|1|0| Word (4 bytes)
	00000004 |0|0|1|1|0|1|0|0|
	00000005 |1|1|1|1|0|1|0|0|
	00000006 |1|0|0|0|0|0|1|1|
	00000007 |0|0|1|0|1|0|1|0| Quad (8 bytes)

3 - Intro to Processor Modes
----------------------------

			 / 64-bit OS and 64-bit programs
			 | 31 64-bit general purpose registers (x0 - x30)
	      / aarch64 -| PSTATE
	      |		 | Stack pointer (SP)
	      |		 | Zero Register (XZR)
       ARMv8 -|		 \ Program Counter(PC)
	      |
	      |		 /
	      \	aarch32	-| Backward Compatibility
			 \

	- ARM instruction size = 1 word (4 bytes)
	- 64-bit GP registers:
		[		XO		] (64 bits)
				[	WO	] (lower 32 bits of XO)
	- Register X30, aka link register, holds return address of procedures
	- Register X29 can be used for frame pointer

#########################################################
#							#
#	   SECTION 3 - DATA REPRESENTATION		#
#							#
#########################################################

4 - Number systems
------------------

	- Decimal (base 10):
		Available digits: [0,1,2,3,4,5,6,7,8,9]

	- Binary (base 2):
		Available digits: [0,1]
		[2³][2²][2¹][2⁰]
			      0
			      1
			  1   0
			  1   1
		      1   0   0
		      1   0   1
		      1   1   0
		      1   1   1
		  1   0   0   0
		  1   0   0   1
		  1   0   1   0
		  1   0   1   1  
		  1   1   0   0
		  1   1   0   1 ---> 1x2³ + 1x2² + 0x2¹ + 1x2⁰
				     = 8 + 4 + 0 + 1
				     = 13

	- Hexadecimal (base 16):
		Available digits: [0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F]
		[16¹][16⁰]
		       0
		       1
		       2
		       3
		       .
		       .
		       D
		       E
		       F
		  1    0
		  1    1
		  1    2
		  1    3 ---> 1x16¹ + 3x16⁰
			      = 16 + 3
			      = 19

	- Convertions:
		| Bin  | Hexa |
		| 0000 |   0  |
		| 0001 |   1  |
		| 0010 |   2  |
		| 0011 |   3  |
		| 0100 |   4  |
		| 0101 |   5  |
		| 0110 |   6  |
		| 0111 |   7  |
		| 1000 |   8  |
		| 1001 |   9  |
		| 1010 |   A  |
		| 1011 |   B  |
		| 1100 |   C  |
		| 1101 |   D  |
		| 1110 |   E  |
		| 1111 |   F  |

		- From binary to hexadecimal:

			1010001001
			/   |   \
		     0010 1000  1001
		       |    |    |
		       2    8    9 ---> 2x16² + 8x16¹ + 2x16⁰
					= 512 + 128 + 9
					= 649

		- From hexadecimal to binary

			 7  A  E
			/   |   \
		     0111 1010 1110

		- How to write them:

			Decimal		20
			Binary		0b10100
			Hexadecimal	0x14

5 - Representing Integers:
--------------------------

	- Unsigned numbers:
		[ 1 Bit ]	[ 2 Bits]	[ 3 Bits]
		  0 = 0		  00 = 0	 000 = 0
		  1 = 1		  01 = 1	 001 = 1
		0 to 2¹-1	  10 = 2	 010 = 2
				  11 = 3	 011 = 3
		[ N Bits]	0 to 2²-1	 100 = 4
	       0 to 2^n -1			 101 = 5
						 110 = 6
						 111 = 7
						0 to 2³-1

	- Positive Signed Numbers:

		[ 8 Bits ]
	   Sign Bit (0 positive, 1 negative)
		\
		 00000000 = 0
		 00101000 = 1x2⁵ + 1x2³
			  = 32 + 8
			  = 40

		 01111111 = 127

		So N-Bit Positive Numbers have range of: 0 to 2^(n-1)-1
							 --------------
	- Negative Signed Numbers:

		Negative numbers use two's complement representation
		[Two's Complement]
	    Sign Bit
		 \
		  10101000 ---> ???
		To convert it, invert every bit and add 1:
		  01010111
		+        1
		= 01011000 ---> 1x2⁶ + 1x2⁴ + 1x2³
				= 64 + 16 + 8
				= -88

		  11111111 ---> ???
		  00000000
		+        1
		= 00000001 ---> 1x2⁰
				= -1

		So N-Bit Negative numbers have range of: -2^(n-1) to 0

	So Signed Numbers have a range of: -2^(n-1) to 2^(n-1)-1
					   ---------------------

6 - ASCII Code
--------------

	American Standard Code for Information Interchange provides 128
	characters, and to each is assigned a unique 7 bits number.

		[Character][Decimal]
		     0	       48
		     a	       97
		     A	       65
		     ?	       63

	A string is composed of one or more characters, and can be converted as:
		  HELLO
		= [H][E][L][L][O]
		= [72][69][76][76][79][0] 0 stand for end of the string,
					  or null-terminated string.

#########################################################
#							#
#	  SECTION 5 - ASSEMBLY LANGUAGE BASICS		#
#							#
#########################################################

8 - Assembling and Linking Basics
---------------------------------

		|'''''''''''''|
		| Source File |
		|,,,,,,,,,,,,,|
		       |
		       |   Assembler
		       |
|'''''''''''|	|'''''''''''''|
| C Library |	| Object File |
|,,,,,,,,,,,|	|,,,,,,,,,,,,,|
      |		       |
      |________________|   Linker
		       |
		|'''''''''''''|
		| Executable  |
		|    File     |
		|,,,,,,,,,,,,,|

9 - The First Program
---------------------

	Here is our first assembly program:

	1  .data
	2  var: .byte 0
	3
	4  .text
	5  .global main
	6  main:
	7          mov x0, #0
	8          ret
	9

	| Label	| opcode | operands | comments			  |
	|-------|--------|----------|-----------------------------|
	| main:	|  mov	 |  x0, #0  | move value 0 to register x0 |
	|	|  ret	 |	    | return to calling procedure |

	To compile the program, run the command: gcc source_file.s -o output_file
	(add -g to add debugging info)

#################################################
#						#
#    SECTION 6 - LOAD AND STORE INSTRUCTIONS	#
#						#
#################################################

			 |''''''''|
			 | ARM v8 |
			 |,,,,,,,,|
		  ____________|_____________
		 |			    |
	|''''''''''''''''|	|'''''''''''''''''''''''|
	|  Load & Store  |	|    Data Processing    |
	|,,,,,,,,,,,,,,,,|	|,,,,,,,,,,,,,,,,,,,,,,,|

	 Load:  Ldr Ldp		 Arithmetic: Add Sub Mul
	 Store: Str Stp		 Logical:    And Orr Eor
				 Shift:      Lsl Lsr

	To proceed arithmetic operation, we need to move data from
	memory to registers, or Load the data.
	To save the result, we need to move data from registers to
	memory, or Store the data.

13 - Ldr Instructions
---------------------

	.data
	value: .quad 0x123456789abcdef

	.text
	.global main
	main:
		// ldr reg, addr
		// Loads the address of value inside register x0.
		ldr x0, =value
		// Loads the value stored at the address saved above
		// inside register x1.
		ldr x1, [x0]

		mov x0, #0
		ret

14 - Str Instructions
---------------------

	cf src/str.s file comments

#########################################################
#							#
#   SECTION 7 - DATA MOVEMENT AND SHIFT INSTRUCTIONS	#
#							#
#########################################################

15 - Shift Left
---------------

	11011011 <- 0 = ?
	(00000001)10110110 Shift Left by 1 bit
	        '
	(00000011)01101100 Shift Left by 2 bits
	       ''
	(00000110)11011000 Shift Left by 3 bits
	      '''
	If variable type is too small, firts bits are lost

	cf src/lsl.s file comments

16 - Shift Right
----------------
			      
			   1 -> 11011011
	Shift Right by 1 bit	11101101
				'
	Shift Right by 2 bits	11110110
				''
	Shift Right by 3 bits	11111011
				'''
			      
			   0 -> 01011011
	Shift Right by 1 bit	00101101
				'
	Shift Right by 2 bits	00010110
				''
	Shift Right by 3 bits	00001011
				'''
	
	cf src/lsr.s file comments

17 - Rotate Instruction
-----------------------

	Rotate Right

	The Rotate Right instruction moves the lowest bit to the highest position
	Rotate Right by 1 bit	11011011 -> 11101101
				       '    '
	Rotate Right by 2 bits	11011011 -> 11110110
				      ''    ''
	Rotate Right by 3 bits	11011011 -> 01111011
				     '''    '''
	
	Rotate Left
	There is no Rotate Left instruction, but we can simulate it with
	Rotate Right by x-n bits, where x is the type size
	
	Rotate Left by 1 bit	11011011 = Rotate Right by 8-1 bits 11011011 -> 10110111
				'				     '''''''	'''''''
	Rotate Left by 2 bits	11011011 = Rotate Right by 8-2 bits 11011011 -> 01101111
				''				      ''''''	''''''
	Rotate Left by 3 bits	11011011 = Rotate Right by 8-3 bits 11011011 -> 11011110
				'''				       '''''	'''''
	
	cf src/rotate.s file comments

18 - Mov Instruction
--------------------

	The mov instruction is used to move the content of a register to another one.
	There is three different mov instruction:
		mov
		movz (move with zeros)
		movk (move with keep)
	
	cf src/mov.s file comments

#################################################################
#								#
#    SECTION 8 - Operand2 and Basic Arithmetic Instructions	#
#								#
#################################################################

19 - Operand2
-------------

	By using operand2, we can perform more than one operation
	in a single instruction.

		    /	#immediate value		(12-bit unsigned value)
	Operand2  __|	register
		    |	register, shift #immediate	(shift, rotate)
		    \	register, extend #immediate	(unsigned and signed
							 extended byte,
							 halfword,
							 word,
							 quad)

20 - Neg Instruction
--------------------

	
